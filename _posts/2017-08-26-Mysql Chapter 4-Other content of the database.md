---
layout: post
title:  "MySQL数据库第4章-数据库的其他内容"
categories: MySQL
tags: MySQL 关系型数据库
---

* content
{:toc}
# 数据库的其他内容

## 一、事务


- 当一个业务逻辑需要多个sql完成时，如果其中某条sql语句出错，则希望整个操作都退回

- 使用事务可以完成退回的功能，保证业务逻辑的正确性

- 事务四大特性(简称ACID)：面试
  - 原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行

  - 一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致

  - 隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。不同的事务之间应该隔离开，使每个并发中的事务不会互相干扰

  - 持久性(Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障


- 要求：表的类型必须是innodb或bdb类型，才可以对此表使用事务

- 查看表的创建语句





```python
show create table students;
```

- 修改表的类型

```python
alter table '表名' engine=innodb;
```

- 事务语句

```
开启事务：
	begin
	或者START TRANSACTION
结束事务：
	提交commit;
	回滚rollback;
```

#### 示例1

- 步骤1：打开两个终端，连接mysql，使用同一个数据库，操作同一张表

```
终端1：
select * from students;
------------------------
终端2：
begin;
insert into students(sname) values('张飞');
```

- 步骤2

```
终端1：
select * from students;
```

- 步骤3

```
终端2：
commit;
------------------------
终端1：
select * from students;
```

#### 示例2

- 步骤1：打开两个终端，连接mysql，使用同一个数据库，操作同一张表

```
终端1：
select * from students;
------------------------
终端2：
begin;
insert into students(sname) values('张飞');
```

- 步骤2

```
终端1：
select * from students;
```

- 步骤3

```
终端2：
rollback;
------------------------
终端1：
select * from students;
```



当使用事务的情况：当数据被更改时：insert，update，delete。





## 二、视图

视图：view，称作是虚拟表。(和真正的数据表非常像)。视图本身是不包含数据。
 视图的创建需要使用对某一个或多个数据表的查询(简单，复杂的)。如果对视图进行增删改操作，其实改的视图的基表。如果基表的数据改变了，视图中的数据也随之改变。

  视图就理解为对一个查询语句的封装。

  创建视图：
    create [or repalce] view view_name
    as 子查询
    [with check option]视图的检查，通过视图的操作，要在视图的可见范围内。

> 通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。
>
> 视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；
>
> 可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；



例如：

```
create view stuscore as 
select students.*,scores.score from scores
inner join students on scores.stuid=students.id;
```

- 视图的用途就是查询

```
select * from stuscore;
```



## 三、索引

思考：在图书馆中，如何找到一本书呢？index

一般的应用系统，读写比例在10:1左右，而且插入操作和更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。

当数据库中数据量很大时，查找 数据会变得很慢

**索引能够提高数据访问性能 ,快速的找到数据**

主键和唯一索引，都是索引，可以提高查询速度

>1.索引可以快速的找到数据
>
>2.数据默认会按照某种索引存储，一般是主键索引
>
>3.索引的创建会增加物理上的开销



**选择列的数据类型**

越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和cpu缓存中都需要更少的空间，处理起来更快

简单的数据类型更好：整型数据比起字符串，处理开销更小，因为字符串的比较更复杂

尽量避免NULL：该应指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该使用0，一个特殊的值或者一个空串代替空值。

**操作**

索引分为单列索引和组合索引

1. 单列索引，即一个索引只包含单个列，一个表可以由多个单列索引，但这不是组合素银
2. 组合索引，即一个索引包含多个列

**查看索引**

```sql
show index from table_name;
```

**创建索引**

```sql
create index index_name on table_name(列)
```

**删除索引**

```sql
drop index index_name on table_name
```

缺点：

1. 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert，update和delete。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件
2. 建立索引会占用磁盘空间的索引文件




## 四、触发器

MySQL包含对触发器的支持。触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。

```sql
CREATE TRIGGER <触发器名称>  --触发器必须有名字，最多64个字符，可能后面会附有分隔符.它和MySQL中其他对象的命名方式基本相象.

{ BEFORE | AFTER }  --触发器有执行的时间设置：可以设置为事件发生前或后。

{ INSERT | UPDATE | DELETE }  --同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。
```

>ON <表名称>  --触发器是属于某一个表的:当在这个表上执行插入、 更新或删除操作的时候就导致触发器的激活. 我们不能给同一张表的同一个事件安排两个触发器。
>
>FOR EACH ROW  --触发器的执行间隔：FOR EACH ROW子句通知触发器 每隔一行执行一次动作，而不是对整个表执行一次。


<触发器SQL语句>  --触发器包含所要触发的SQL语句：这里的语句可以是任何合法的语句， 包括复合语句，但是这里的语句受的限制和函数的一样。

你必须拥有相当大的权限才能创建触发器（CREATE TRIGGER），如果你已经是Root用户，那么就足够了。这跟SQL的标准有所不同。